<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
        body {
            margin: 0;
        }
        
        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="../js/three.min.js"></script>
    <script src="THREEx.KeyboardState.js"></script>
    <script>
        //
        //Stefan Koch, 2016
        //https://github.com/StefanKochGit/three-tests.git
        //
        var particles, geometry, material, parameters, i, h, color, size;
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 9000);
		camera.position.z = -2000;
        camTarget = new THREE.Vector3(0, 0, -1);
        camera.lookAt(camera.position + camTarget);
        var scene = new THREE.Scene();
		var keyboard = new THREEx.KeyboardState();

        //###############################################################################
        sprite = new THREE.TextureLoader().load("star.png");

        //this is the edge length of the cube forming space
        var maxSpaceSize = 2000;

        //particle counter
        var numParticles = 0;

        //max dist normal
        var maxNormResolution = 100;
        var maxNorm = Math.floor(Math.sqrt(3) * maxNormResolution);

        //this is the histogram array
        var hist = [];

        //this is the probability envelope
        var probEnv = [];

        //setup the probabiliy envelope and historam
        function setupProbEnv() {
            for (var i = 0; i < maxNorm; i++) {
                probEnv[i] = 0.0;
                hist[i] = 0.0;
            }
            //we use some quadratic function: f(x) = 1 / ((x*x/5)+1)
            for (var i = 0; i < 100; i++) {
                probEnv[i] = 1 / ((i * i / 5) + 1);
            }
        }

        //function for non-uniformly distribued random numbers
        //based on sorting along a probability envelope
        //returns range -1...1
        function nurd3d() {
            numParticles += 1;
            var x = 0;
            var y = 0;
            var z = 0;
            var xyz = {};

            //search a point within distribution
            while (1) {
                //get candidate position
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
                z = Math.random() * 2 - 1;

                //map to histogram
                var dist = Math.sqrt((x * x) + (y * y) + (z * z));
                var bucket = Math.floor(dist * maxNormResolution);

                //in case of an error - dont blow up
                if (bucket > maxNorm) {
                    bucket = maxNorm;
                }

                //probe if the added position would leave the target
                //probability distribution for this specific distance
                //to the origin, if result is negative then try again
                var curprob = (hist[bucket] + 1) / numParticles;
                if (curprob > probEnv[bucket]) {
                    continue;
                }
                //position is within the target envelope
                hist[bucket] += 1;
                break;
            }
            xyz['x'] = x;
            xyz['y'] = y;
            xyz['z'] = z;
            return xyz;
        }

        //function for uniformly distribued random numbers
        //returns range -1...1
        function urd3d() {
            var xyz = {};

            //this is a simple uniform random distribution
            var x = Math.random() * 2 - 1;
            var y = Math.random() * 2 - 1;
            var z = Math.random() * 2 - 1;

            xyz['x'] = x;
            xyz['y'] = y;
            xyz['z'] = z;
            return xyz;
        }

        //generates the particle system
        //mode = 0 --> simple uniform distribution
        //mode = 1 --> use probEnv distribution envelope
        function genParticles(num, mode, cent, scale) {
            geometry = new THREE.Geometry();

            for (var i = 0; i < num; i++) {
                var vertex = new THREE.Vector3();
                if (mode == 1) {
                    var xyz = nurd3d();
                } else {
                    var xyz = urd3d();
                }

                vertex.x = cent['x'] + (scale * xyz['x'] * maxSpaceSize);
                vertex.y = cent['y'] + (scale * xyz['y'] * maxSpaceSize);
                vertex.z = cent['z'] + (scale * xyz['z'] * maxSpaceSize);
                geometry.vertices.push(vertex);
            }

            //for this run we pick a random size
            size = Math.random() * 20;
            material = new THREE.PointsMaterial({
                size: size,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        //particle generation in chunks to allow different sizes to be generated
        function makeParticles(num, rounds, mode, center, scale) {
            var chunk = num / rounds;

            for (var k = 0; k < rounds; k++) {
                genParticles(chunk, mode, center, scale);
            }
        }

        var center1 = { 'x': 0.0, 'y': 0.0, 'z': 0.0 };
        var center2 = { 'x': 0.0, 'y': 0.0, 'z': -2000.0 };

        setupProbEnv();
        makeParticles(10000, 100, 1, center1, 1.0);
        makeParticles(1000, 100, 1, center2, 0.4);

        // this is the surrounding space (uses urd)
        makeParticles(1000, 100, 0, center1, 1.0);

        var camTmp   = new THREE.Vector3();
        var targTmp  = new THREE.Vector3();
		var len = 0;
		var lr  = 0;
		var ud  = 0;

        //###############################################################################
        function animate() {
            requestAnimationFrame(animate);

			if (keyboard.pressed("pageup")) {
            	len += 0.01;
			}

			if (keyboard.pressed("pagedown")) {
            	len -= 0.0001;
			}

			if (keyboard.pressed("up")) {
				ud += 0.0001;
			}

			if (keyboard.pressed("down")) {
				ud -= 0.0001;
			}

			if (keyboard.pressed("right")) {
				lr += 0.0001;
			}

			if (keyboard.pressed("left")) {
				lr -= 0.0001;
			}
			//set camTarget
			var pitchVec = new THREE.Vector3(0, 1, 0);
			var yawVec   = new THREE.Vector3(camTarget.x, 0, camTarget.z);
			yawVec.applyAxisAngle(pitchVec, Math.PI/2);
			yawVec.normalize();
			camTarget.applyAxisAngle(yawVec, ud);
			camTarget.applyAxisAngle(pitchVec, lr);
			camTarget.normalize();

            targTmp.copy(camTarget);
            if (len < 0) {
                targTmp.negate();
            }
            targTmp.setLength(Math.abs(len));

            camera.position.add(targTmp);
            camTmp.addVectors(camera.position, camTarget);
            camera.lookAt(camTmp);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
